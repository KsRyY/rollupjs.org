[{"html":"<h3 id=\"-overview-\">概述(Overview)</h3>\n<p>Rollup 是一个 JavaScript 模块打包器，可以将小块代码编译成大块复杂的代码，例如 library 或应用程序。Rollup 对代码模块使用新的标准化格式，这些标准都包含在 JavaScript 的 ES6 版本中，而不是以前的特殊解决方案，如 CommonJS 和 AMD。ES6 模块可以使你自由、无缝地使用你最喜爱的 library 中那些最有用独立函数，而你的项目不必携带其他未使用的代码。ES6 模块最终还是要由浏览器原生实现，但当前 Rollup 可以使你提前体验。</p>\n<h3 id=\"-quick-start-\">快速入门指南(Quick start)</h3>\n<p>使用 <code>npm install --global rollup</code> 进行安装。Rollup 可以通过<a href=\"https://github.com/rollup/rollup/wiki/Command-Line-Interface\">命令行接口(command line interface)</a>配合可选配置文件(optional configuration file)来调用，或者可以通过 <a href=\"https://github.com/rollup/rollup/wiki/JavaScript-API\">JavaScript API</a>来调用。运行 <code>rollup --help</code> 可以查看可用的选项和参数。</p>\n<blockquote>\n<p>查看 <a href=\"https://github.com/rollup/rollup-starter-lib\">rollup-starter-lib</a> 和 <a href=\"https://github.com/rollup/rollup-starter-app\">rollup-starter-app</a> 中那些使用 Rollup 的示例类库与应用项目。</p>\n</blockquote>\n<p>这些命令假设应用程序入口起点的名称为 main.js，并且你想要所有 import 的依赖(all imports)都编译到一个名为 bundle.js 的单个文件中。</p>\n<p>对于浏览器：</p>\n<pre><code><span class=\"hljs-comment\"># compile to a &lt;script&gt; containing a self-executing function ('iife')</span>\n$ rollup main.js --o bundle.js --f iife\n</code></pre>\n<p>对于 Node.js:</p>\n<pre><code><span class=\"hljs-comment\"># compile to a CommonJS module ('cjs')</span>\n$ rollup main.js --o bundle.js --f cjs\n</code></pre>\n<p>对于浏览器和 Node.js:</p>\n<pre><code><span class=\"hljs-comment\"># UMD format requires a bundle name</span>\n$ rollup main.js --o bundle.js -f umd --name <span class=\"hljs-string\">\"myBundle\"</span>\n</code></pre>\n<h3 id=\"-why-\">为什么(Why)</h3>\n<p>如果你将项目拆分成小的单独文件中，这样开发软件通常会很简单，因为这通常会消除无法预知的相互影响(remove unexpected interaction)，以及显著降低了所要解决的问题的复杂度(complexity of the problem)，并且可以在项目最初时，就简洁地编写小的项目（<a href=\"https://medium.com/@Rich_Harris/small-modules-it-s-not-quite-that-simple-3ca532d65de4\">不一定是标准答案</a>）。不幸的是，JavaScript 以往并没有将此功能作为语言的核心功能。</p>\n<h3 id=\"tree-shaking\">Tree-shaking</h3>\n<p>除了使用 ES6 模块之外，Rollup 还静态分析代码中的 import，并将排除任何未实际使用的代码。这允许您架构于现有工具和模块之上，而不会增加额外的依赖或使项目的大小膨胀。</p>\n<p>例如，在使用 CommonJS 时，<em>必须导入(import)完整的工具(tool)或库(library)对象</em>。</p>\n<pre><code><span class=\"hljs-comment\">// 使用 CommonJS 导入(import)完整的 utils 对象</span>\n<span class=\"hljs-keyword\">var</span> utils = <span class=\"hljs-built_in\">require</span>( <span class=\"hljs-string\">'utils'</span> );\n<span class=\"hljs-keyword\">var</span> query = <span class=\"hljs-string\">'Rollup'</span>;\n<span class=\"hljs-comment\">// 使用 utils 对象的 ajax 方法</span>\nutils.ajax( <span class=\"hljs-string\">'https://api.example.com?search='</span> + query ).then( handleResponse );\n</code></pre>\n<p>但是在使用 ES6 模块时，无需导入整个 <code>utils</code> 对象，我们可以只导入(import)我们所需的 <code>ajax</code> 函数：</p>\n<pre><code><span class=\"hljs-comment\">// 使用 ES6 import 语句导入(import) ajax 函数</span>\n<span class=\"hljs-keyword\">import</span> { ajax } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'utils'</span>;\n<span class=\"hljs-keyword\">var</span> query = <span class=\"hljs-string\">'Rollup'</span>;\n<span class=\"hljs-comment\">// 调用 ajax 函数</span>\najax( <span class=\"hljs-string\">'https://api.example.com?search='</span> + query ).then( handleResponse );\n</code></pre>\n<p>因为 Rollup 只引入最基本最精简代码，所以可以生成轻量、快速，以及低复杂度的 library 和应用程序。因为这种基于显式的 <code>import</code> 和 <code>export</code> 语句的方式，它远比「在编译后的输出代码中，简单地运行自动 minifier 检测未使用的变量」更有效。</p>\n<h3 id=\"-compatibility-\">兼容性(Compatibility)</h3>\n<h4 id=\"-commonjs-importing-commonjs-\">导入 CommonJS(Importing CommonJS)</h4>\n<p>Rollup 可以<a href=\"https://github.com/rollup/rollup-plugin-commonjs\">通过插件</a>导入已存在的 CommonJS 模块。</p>\n<h4 id=\"-es6-publishing-es6-modules-\">发布 ES6 模块(Publishing ES6 Modules)</h4>\n<p>为了确保你的 ES6 模块可以直接与「运行在 CommonJS（例如 Node.js 和 webpack）中的工具(tool)」使用，你可以使用 Rollup 编译为 UMD 或 CommonJS 格式，然后在 <code>package.json</code> 文件的 <code>main</code> 属性中指向当前编译的版本。如果你的 <code>package.json</code> 也具有 <code>module</code> 字段，像 Rollup 和 <a href=\"https://webpack.js.org/\">webpack 2</a> 这样的 ES6 感知工具(ES6-aware tools)将会直接<a href=\"https://github.com/rollup/rollup/wiki/pkg.module\">导入 ES6 模块版本</a>。</p>\n<h3 id=\"-links-\">参考链接(Links)</h3>\n<ul>\n<li>step-by-step <a href=\"https://code.lengstorf.com/learn-rollup-js/\">tutorial video series</a>, with accompanying written walkthrough</li>\n<li>miscellaneous issues in the <a href=\"https://github.com/rollup/rollup/wiki\">wiki</a></li>\n</ul>\n<hr>\n<blockquote>\n<p>原文：<a href=\"https://rollupjs.org/#introduction\">https://rollupjs.org/#introduction</a></p>\n</blockquote>\n","metadata":{"title":"介绍"},"subsections":[{"slug":"-overview-","title":"概述"},{"slug":"-quick-start-","title":"快速入门指南"},{"slug":"-why-","title":"为什么"},{"slug":"tree-shaking","title":"Tree-shaking"},{"slug":"-compatibility-","title":"兼容性"},{"slug":"-links-","title":"参考链接"}],"slug":"introduction"},{"html":"<h4 id=\"-es-commonjs-why-are-es-modules-better-than-commonjs-modules-\">为什么ES模块比CommonJS更好?(Why are ES modules better than CommonJS modules?)</h4>\n<p>ES模块是官方标准，也是JavaScript语言明确的发展方向，而CommonJS模块是一种特殊的传统格式，在ES模块被提出之前做为暂时的解决方案。 ES模块允许进行静态分析，从而实现像 tree-shaking 的优化，并提供诸如循环引用和动态绑定等高级功能。</p>\n<h4 id=\"-tree-shaking-what-is-tree-shaking-\">什么是 ‘tree-shaking’?(What is &quot;tree-shaking?&quot;)</h4>\n<p>Tree-shaking, 也被称为 &quot;live code inclusion,&quot; 它是清除实际上并没有在给定项目中使用的代码的过程，但是它可以更加高效。词汇来源查看：<a href=\"https://medium.com/@Rich_Harris/tree-shaking-versus-dead-code-elimination-d3765df85c80#.jnypozs9n\">与清除无用代码相似</a> </p>\n<h4 id=\"-commonjs-rollup-how-do-i-use-rollup-in-node-js-with-commonjs-modules-\">我如何在 CommonJS 模块中使用 Rollup ?(How do I use Rollup in Node.js with CommonJS modules?)</h4>\n<p>Rollup 力图实现 ES 模块的规范，而不一定是 Node.js, npm, <code>require()</code>, 和 CommonJS 的特性。 因此，加载 CommonJS 模块和使用 Node 模块位置解析逻辑都被实现为可选插件，默认情况下不在 Rollup 内核中。 你只需要执行 <code>npm install</code> 安装 <a href=\"https://github.com/rollup/rollup-plugin-commonjs\">CommonJS</a> 和 <a href=\"https://github.com/rollup/rollup-plugin-node-resolve\">node-resolve</a> 插件然后使用 <code>rollup.config.js</code> 配置文件启用他们，那你就完成了所有设置。</p>\n<h4 id=\"rollup-is-rollup-meant-for-building-libraries-or-applications-\">Rollup 是用来构建库还是应用程序？(Is Rollup meant for building libraries or applications?)</h4>\n<p>Rollup 已被许多主流的 JavaScript 库使用，也可用于构建绝大多数应用程序。但是 Rollup 还不支持一些特定的高级功能，尤其是用在构建一些应用程序的时候，特别是代码拆分和运行时态的动态导入 <a href=\"https://github.com/tc39/proposal-dynamic-import\">dynamic imports at runtime</a>. 如果你的项目中更需要这些功能，那使用 <a href=\"https://webpack.js.org/\">Webpack</a>可能更符合你的需求。</p>\n<h4 id=\"-rollup-logo-who-made-the-rollup-logo-it-s-lovely-\">谁制作了 Rollup 的 Logo。太可爱了!(Who made the Rollup logo? It&#39;s lovely.)</h4>\n<p>我就知道! 是<a href=\"https://twitter.com/jlmakes\">Julian Lloyd.</a>制作的。</p>\n","metadata":{"title":"常见问题"},"subsections":[],"slug":"faqs"},{"html":"<h3 id=\"-bundle-creating-your-first-bundle-\">创建第一个bundle(Creating your first bundle)</h3>\n<p><em>开始前, 需要安装 <a href=\"https://nodejs.org\">Node.js</a>， 这样才可以使用 <a href=\"https://npmjs.com\">npm</a> ；还需要了解如何使用 <a href=\"https://www.codecademy.com/learn/learn-the-command-line\">command line</a>。</em></p>\n<p>使用 Rollup 最简单的方法是通过 Command Line Interface （或 CLI）。先全局安装 Rollup （之后会介绍如何在项目中进行安装，更便于打包，但现在不用担心这个问题）。在命令行中输入以下内容：</p>\n<pre><code>npm install rollup --global <span class=\"hljs-comment\"># or `npm i rollup -g` for short</span>\n</code></pre>\n<p>现在可以运行 <code>rollup</code> 命令了。试试吧~</p>\n<pre><code>rollup\n</code></pre>\n<p>由于没有传递参数，所以 Rollup 打印出了使用说明。这和运行 <code>rollup --help</code> 或 <code>rollup -h</code> 的效果一样。</p>\n<p>我们来创建一个简单的项目：</p>\n<pre><code>mkdir -p my-rollup-project/src\n<span class=\"hljs-built_in\">cd</span> my-rollup-project\n</code></pre>\n<p>首先，我们需要个 <em>入口</em>。将以下代码粘贴到新建的文件 <code>src/main.js</code> 中：</p>\n<pre><code><span class=\"hljs-comment\">// src/main.js</span>\n<span class=\"hljs-keyword\">import</span> foo <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./foo.js'</span>;\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(foo);\n}\n</code></pre>\n<p>之后创建入口文件引用的 <code>foo.js</code> 模块：</p>\n<pre><code><span class=\"hljs-comment\">// src/foo.js</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-string\">'hello world!'</span>;\n</code></pre>\n<p>现在可以创建 bundle 了：</p>\n<pre><code>rollup src/main.js -f cjs\n</code></pre>\n<p><code>-f</code> 选项（<code>--output.format</code> 的缩写）指定了所创建 bundle 的类型——这里是 CommonJS（在 Node.js 中运行）。由于没有指定输出文件，所以会直接打印在 <code>stdout</code> 中：</p>\n<pre><code><span class=\"hljs-meta\">'use strict'</span>;\n\n<span class=\"hljs-keyword\">var</span> foo = <span class=\"hljs-string\">'hello world!'</span>;\n\n<span class=\"hljs-keyword\">var</span> main = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(foo);\n};\n\n<span class=\"hljs-built_in\">module</span>.exports = main;\n</code></pre>\n<p>也可以像下面一样将 bundle 保存为文件：</p>\n<pre><code>rollup src/main.js -o bundle.js -f cjs\n</code></pre>\n<p>（你也可以用 <code>rollup src/main.js -f cjs &gt; bundle.js</code>，但是我们之后会提到，这种方法在生成 sourcemap 时灵活性不高。）</p>\n<p>试着运行下面的代码：</p>\n<pre><code>node\n&gt; var myBundle = require(<span class=\"hljs-string\">'./bundle.js'</span>);\n&gt; myBundle();\n<span class=\"hljs-string\">'hello world!'</span>\n</code></pre>\n<p>恭喜，你已经用 Rollup 完成了第一个 bundle。</p>\n<h3 id=\"-using-config-files-\">使用配置文件(Using config files)</h3>\n<p>上面的方式还不错，但是如果添加更多的选项，这种命令行的方式就显得麻烦了。</p>\n<p>为此，我们可以创建配置文件来囊括所需的选项。配置文件由 JavaScript 写成，比 CLI 更加灵活。</p>\n<p>在项目中创建一个名为 <code>rollup.config.js</code> 的文件，增加如下代码：</p>\n<pre><code><span class=\"hljs-comment\">// rollup.config.js</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  <span class=\"hljs-attr\">input</span>: <span class=\"hljs-string\">'src/main.js'</span>,\n  <span class=\"hljs-attr\">output</span>: {\n    <span class=\"hljs-attr\">file</span>: <span class=\"hljs-string\">'bundle.js'</span>,\n    <span class=\"hljs-attr\">format</span>: <span class=\"hljs-string\">'cjs'</span>\n  }\n};\n</code></pre>\n<p>我们用 <code>--config</code> 或 <code>-c</code> 来使用配置文件：</p>\n<pre><code>rm bundle.js <span class=\"hljs-comment\"># so we can check the command works!</span>\nrollup -c\n</code></pre>\n<p>同样的命令行选项将会覆盖配置文件中的选项：</p>\n<pre><code>rollup -c -o bundle-2.js <span class=\"hljs-comment\"># `-o` is short for `--output.file`</span>\n</code></pre>\n<p>（注意 Rollup 本身会处理配置文件，所以可以使用 <code>export default</code> 语法——代码不会经过 Babel 等类似工具编译，所以只能使用所用 Node.js 版本支持的 ES2015 语法。）</p>\n<p>如果愿意的话，也可以指定与默认 <code>rollup.config.js</code> 文件不同的配置文件：</p>\n<pre><code>rollup --config rollup.config.dev.js\nrollup --config rollup.config.prod.js\n</code></pre>\n<h3 id=\"-using-plugins-\">使用插件(Using plugins)</h3>\n<p>目前为止，我们通过相对路径，将一个入口文件和一个模块创建成了一个简单的 bundle。随着构建更复杂的 bundle，通常需要更大的灵活性——引入 npm 安装的模块、通过 Babel 编译代码、和 JSON 文件打交道等。</p>\n<p>为此，我们可以用 <em>插件(plugins)</em> 在打包的关键过程中更改 Rollup 的行为。<a href=\"https://github.com/rollup/rollup/wiki/Plugins\">the Rollup wiki</a> 维护了可用的插件列表。</p>\n<p>此教程中，我们将使用 <a href=\"https://github.com/rollup/rollup-plugin-json\">rollup-plugin-json</a>，令 Rollup 从 JSON 文件中读取数据。</p>\n<p>将 rollup-plugin-json 安装为开发依赖：</p>\n<pre><code>npm install --save-dev rollup-plugin-json\n</code></pre>\n<p>（我们用的是 <code>--save-dev</code> 而不是 <code>--save</code>，因为代码实际执行时不依赖这个插件——只是在打包时使用。）</p>\n<p>更新 <code>src/main.js</code> 文件，从 package.json 而非 <code>src/foo.js</code> 中读取数据：</p>\n<pre><code><span class=\"hljs-comment\">// src/main.js</span>\n<span class=\"hljs-keyword\">import</span> { version } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'../package.json'</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'version '</span> + version);\n}\n</code></pre>\n<p>编辑 <code>rollup.config.js</code> 文件，加入 JSON 插件：</p>\n<pre><code><span class=\"hljs-comment\">// rollup.config.js</span>\n<span class=\"hljs-keyword\">import</span> json <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rollup-plugin-json'</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  <span class=\"hljs-attr\">input</span>: <span class=\"hljs-string\">'src/main.js'</span>,\n  <span class=\"hljs-attr\">output</span>: {\n    <span class=\"hljs-attr\">file</span>: <span class=\"hljs-string\">'bundle.js'</span>,\n    <span class=\"hljs-attr\">format</span>: <span class=\"hljs-string\">'cjs'</span>\n  },\n  <span class=\"hljs-attr\">plugins</span>: [ json() ]\n};\n</code></pre>\n<p><code>npm run build</code> 执行 Rollup。结果如下：</p>\n<pre><code><span class=\"hljs-meta\">'use strict'</span>;\n\n<span class=\"hljs-keyword\">var</span> version = <span class=\"hljs-string\">\"1.0.0\"</span>;\n\n<span class=\"hljs-keyword\">var</span> main = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'version '</span> + version);\n};\n\n<span class=\"hljs-built_in\">module</span>.exports = main;\n</code></pre>\n<p>（注意只有我们实际需要的数据——name 和 devDependencies 和 package.json 中的其它数据被忽略了。这是 tree-shaking 起了作用。）</p>\n","metadata":{"title":"教程"},"subsections":[{"slug":"-bundle-creating-your-first-bundle-","title":"创建第一个bundle"},{"slug":"-using-config-files-","title":"使用配置文件"},{"slug":"-using-plugins-","title":"使用插件"}],"slug":"tutorial"},{"html":"<p>我们一般在命令行中使用Rollup。你也可以提供一份配置文件（可要可不要）来简化命令行操作，同时还能启用Rollup的高级特性</p>\n<h3 id=\"-configuration-files-\">配置文件(Configuration files)</h3>\n<p>Rollup的配置文件是可选的，但是使用配置文件的作用很强大，而且很方便，因此我们推荐你使用</p>\n<p>配置文件是一个ES6模块，它对外暴露一个对象，这个对象包含了一些Rollup需要的一些选项。通常，我们把这个配置文件叫做<code>rollup.config.js</code>，它通常位于项目的根目录</p>\n<p>仔细查阅这个<a href=\"#big-list-of-options\">包办大量选项的清单</a>，你可以根据你自己的需要把它配置到你的配置文件中</p>\n<pre><code><span class=\"hljs-comment\">// rollup.config.js</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  <span class=\"hljs-comment\">// 核心选项</span>\n  input,     <span class=\"hljs-comment\">// 必须</span>\n  external,\n  plugins,\n\n  <span class=\"hljs-comment\">// 额外选项</span>\n  onwarn,\n\n  <span class=\"hljs-comment\">// danger zone</span>\n  acorn,\n  context,\n  moduleContext,\n  legacy\n\n  output: {  <span class=\"hljs-comment\">// 必须 (如果要输出多个，可以是一个数组)</span>\n    <span class=\"hljs-comment\">// 核心选项</span>\n    file,    <span class=\"hljs-comment\">// 必须</span>\n    format,  <span class=\"hljs-comment\">// 必须</span>\n    name,\n    globals,\n\n    <span class=\"hljs-comment\">// 额外选项</span>\n    paths,\n    banner,\n    footer,\n    intro,\n    outro,\n    sourcemap,\n    sourcemapFile,\n    interop,\n\n    <span class=\"hljs-comment\">// 高危选项</span>\n    exports,\n    amd,\n    indent\n    strict\n  },\n};\n</code></pre>\n<p>你必须使用配置文件才能执行以下操作：</p>\n<ul>\n<li>把一个项目打包，然后输出多个文件</li>\n<li>使用Rollup插件, 例如 <a href=\"https://github.com/rollup/rollup-plugin-node-resolve\">rollup-plugin-node-resolve</a> 和 <a href=\"https://github.com/rollup/rollup-plugin-commonjs\">rollup-plugin-commonjs</a> 。这两个插件可以让你加载Node.js里面的CommonJS模块</li>\n</ul>\n<p>如果你想使用Rollup的配置文件，记得在命令行里加上<code>--config</code>或者<code>-c</code>\n@@2</p>\n<h3 id=\"-command-line-flags-\">命令行的参数(Command line flags)</h3>\n<p>配置文件中的许多选项和命令行的参数是等价的。如果你使用这里的参数，那么将重写配置文件。想了解更多的话，仔细查阅这个<a href=\"#big-list-of-options\">包办大量选项的清单</a></p>\n<pre><code>-i, --input                 要打包的文件（必须）\n-o, --output.file           输出的文件 (如果没有这个参数，则直接输出到控制台)\n-f, --output.format [es]    输出的文件类型 (amd, cjs, es, iife, umd)\n-e, --external              将模块ID的逗号分隔列表排除\n-g, --globals               以`module ID:Global` 键值对的形式，用逗号分隔开 \n                              任何定义在这里模块ID定义添加到外部依赖\n-n, --name                  生成UMD模块的名字\n-m, --sourcemap             生成 sourcemap (`-m inline` <span class=\"hljs-keyword\">for</span> inline map)\n--amd.id                    AMD模块的ID，默认是个匿名函数\n--amd.define                使用Function来代替`define`\n--no-strict                 在生成的包中省略`<span class=\"hljs-string\">\"use strict\"</span>;`\n--no-conflict               对于UMD模块来说，给全局变量生成一个无冲突的方法\n--intro                     在打包好的文件的块的内部(wrapper内部)的最顶部插入一段内容\n--outro                     在打包好的文件的块的内部(wrapper内部)的最底部插入一段内容\n--banner                    在打包好的文件的块的外部(wrapper外部)的最顶部插入一段内容\n--footer                    在打包好的文件的块的外部(wrapper外部)的最底部插入一段内容\n--interop                   包含公共的模块（这个选项是默认添加的）\n</code></pre>\n<p>此外，还可以使用以下参数：</p>\n<h4 id=\"-h-help-\"><code>-h</code>/<code>--help</code></h4>\n<p>打印帮助文档。</p>\n<h4 id=\"-v-version-\"><code>-v</code>/<code>--version</code></h4>\n<p>打印已安装的Rollup版本号。</p>\n<h4 id=\"-w-watch-\"><code>-w</code>/<code>--watch</code></h4>\n<p>监听源文件是否有改动，如果有改动，重新打包</p>\n<h4 id=\"-silent-\"><code>--silent</code></h4>\n<p>不要将警告打印到控制台。</p>\n","metadata":{"title":"命令行"},"subsections":[{"slug":"-configuration-files-","title":"配置文件"},{"slug":"-command-line-flags-","title":"命令行的参数"}],"slug":"command-line-reference"},{"html":"<p>Rollup 提供 JavaScript 接口那样可以通过 Node.js 来使用。你可以很少使用，而且很可能使用命令行接口，除非你想扩展 Rollup 本身，或者用于一些难懂的任务，例如用代码把文件束生成出来。</p>\n<h3 id=\"rollup-rollup\">rollup.rollup</h3>\n<p>The <code>rollup.rollup</code> 函数返回一个 Promise，它解析了一个 <code>bundle</code> 对象，此对象带有不同的属性及方法，如下：</p>\n<pre><code><span class=\"hljs-keyword\">const</span> rollup = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'rollup'</span>);\n\n<span class=\"hljs-comment\">// see below for details on the options</span>\n<span class=\"hljs-keyword\">const</span> inputOptions = {...};\n<span class=\"hljs-keyword\">const</span> outputOptions = {...};\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">build</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-comment\">// create a bundle</span>\n  <span class=\"hljs-keyword\">const</span> bundle = <span class=\"hljs-keyword\">await</span> rollup.rollup(inputOptions);\n\n  <span class=\"hljs-built_in\">console</span>.log(bundle.imports); <span class=\"hljs-comment\">// an array of external dependencies</span>\n  <span class=\"hljs-built_in\">console</span>.log(bundle.exports); <span class=\"hljs-comment\">// an array of names exported by the entry point</span>\n  <span class=\"hljs-built_in\">console</span>.log(bundle.modules); <span class=\"hljs-comment\">// an array of module objects</span>\n\n  <span class=\"hljs-comment\">// generate code and a sourcemap</span>\n  <span class=\"hljs-keyword\">const</span> { code, map } = <span class=\"hljs-keyword\">await</span> bundle.generate(outputOptions);\n\n  <span class=\"hljs-comment\">// or write the bundle to disk</span>\n  <span class=\"hljs-keyword\">await</span> bundle.write(outputOptions);\n}\n\nbuild();\n</code></pre>\n<h4 id=\"-inputoptions-\">输入参数(inputOptions)</h4>\n<p><code>inputOptions</code> 对象包含下列属性 (查看<a href=\"#big-list-of-options\">big list of options</a> 以获得这些参数更详细的资料):</p>\n<pre><code><span class=\"hljs-keyword\">const</span> inputOptions = {\n  <span class=\"hljs-comment\">// 核心参数</span>\n  input, <span class=\"hljs-comment\">// 唯一必填参数</span>\n  external,\n  plugins,\n\n  <span class=\"hljs-comment\">// 高级参数</span>\n  onwarn,\n  cache,\n\n  <span class=\"hljs-comment\">// 危险参数</span>\n  acorn,\n  context,\n  moduleContext,\n  legacy\n};\n</code></pre>\n<h4 id=\"-outputoptions-\">输出参数(outputOptions)</h4>\n<p><code>outputOptions</code> 对象包括下列属性 (查看 <a href=\"#big-list-of-options\">big list of options</a> 以获得这些参数更详细的资料):</p>\n<pre><code><span class=\"hljs-keyword\">const</span> outputOptions = {\n  <span class=\"hljs-comment\">// 核心参数</span>\n  file,   <span class=\"hljs-comment\">// 若有bundle.write，必填</span>\n  format, <span class=\"hljs-comment\">// 必填</span>\n  name,\n  globals,\n\n  <span class=\"hljs-comment\">// 高级参数</span>\n  paths,\n  banner,\n  footer,\n  intro,\n  outro,\n  sourcemap,\n  sourcemapFile,\n  interop,\n\n  <span class=\"hljs-comment\">// 危险区域</span>\n  exports,\n  amd,\n  indent\n  strict\n};\n</code></pre>\n<h3 id=\"rollup-watch\">rollup.watch</h3>\n<p>Rollup 也提供了 <code>rollup.watch</code> 函数，当它检测到磁盘上单个模块已经改变，它会重新构建你的文件束。 当你通过命令行运行 Rollup，并带上 <code>--watch</code> 标记时，此函数会被内部使用。</p>\n<pre><code><span class=\"hljs-keyword\">const</span> rollup = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'rollup'</span>);\n\n<span class=\"hljs-keyword\">const</span> watchOptions = {...};\n<span class=\"hljs-keyword\">const</span> watcher = rollup.watch(watchOptions);\n\nwatcher.on(<span class=\"hljs-string\">'event'</span>, event =&gt; {\n  <span class=\"hljs-comment\">// event.code 会是下面其中一个：</span>\n  <span class=\"hljs-comment\">//   START        — 监听器正在启动（重启）</span>\n  <span class=\"hljs-comment\">//   BUNDLE_START — 构建单个文件束</span>\n  <span class=\"hljs-comment\">//   BUNDLE_END   — 完成文件束构建</span>\n  <span class=\"hljs-comment\">//   END          — 完成所有文件束构建</span>\n  <span class=\"hljs-comment\">//   ERROR        — 构建时遇到错误</span>\n  <span class=\"hljs-comment\">//   FATAL        — 遇到无可修复的错误</span>\n});\n\n<span class=\"hljs-comment\">// 停止监听</span>\nwatcher.close();\n</code></pre>\n<h4 id=\"-watchoptions-\">监听参数(watchOptions)</h4>\n<p><code>watchOptions</code> 参数是一个你会从一个配置文件中导出的配置 (或一个配置数据)。</p>\n<pre><code><span class=\"hljs-keyword\">const</span> watchOptions = {\n  ...inputOptions,\n  <span class=\"hljs-attr\">output</span>: [outputOptions],\n  <span class=\"hljs-attr\">watch</span>: {\n    chokidar,\n    include,\n    exclude\n  }\n};\n</code></pre>\n<p>查看以上文档知道更多 <code>inputOptions</code> 和 <code>outputOptions</code> 的细节, 或查询 <a href=\"#big-list-of-options\">big list of options</a> 关 <code>chokidar</code>, <code>include</code> 和 <code>exclude</code> 的资料。</p>\n","metadata":{"title":"JavaScript API"},"subsections":[{"slug":"rollup-rollup","title":"rollup.rollup"},{"slug":"rollup-watch","title":"rollup.watch"}],"slug":"javascript-api"},{"html":"<h3 id=\"npm-packages\">npm packages</h3>\n<p>在某些时候，你的项目很可能依赖于从npm安装到你的<code>node_modules</code>文件夹中的软件包。 与Webpack和Browserify这样的其他捆绑包不同，Rollup不知道如何打破常规去处理这些依赖。 - 我们需要添加一些配置。</p>\n<p>让我们添加一个简单的依赖 <a href=\"https://www.npmjs.com/package/the-answer\">the-answer</a>，它输出对生活、宇宙及其它一切的答案</p>\n<pre><code>npm install the-answer <span class=\"hljs-comment\"># or `npm i the-answer`</span>\n</code></pre>\n<p>如果修改我们的 <code>src/main.js</code> 入口文件...</p>\n<pre><code><span class=\"hljs-comment\">// src/main.js</span>\n<span class=\"hljs-keyword\">import</span> answer <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'the-answer'</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'the answer is '</span> + answer);\n}\n</code></pre>\n<p>...然后执行 Rollup...</p>\n<pre><code>npm run build\n</code></pre>\n<p>...我们将会看到下面这些警告：</p>\n<pre><code>(!) Unresolved dependencies\nhttps://github.com/rollup/rollup/wiki/Troubleshooting<span class=\"hljs-comment\">#treating-module-as-external-dependency</span>\nthe-answer (imported by main.js)\n</code></pre>\n<p>打包后的<code>bundle.js</code>仍然会在 Node.js 中工作，因为<code>import</code>声明转变成了 CommonJS中的 <code>require</code> 语句，但是<code>the-answer</code>不包含在包中。因此，我们需要一个插件。</p>\n<h4 id=\"rollup-plugin-node-resolve\">rollup-plugin-node-resolve</h4>\n<p>这个 <a href=\"https://github.com/rollup/rollup-plugin-node-resolve\">rollup-plugin-node-resolve</a> 插件可以告诉 Rollup 如何查找外部模块。\n安装它...</p>\n<pre><code>npm install --save-dev rollup-plugin-node-resolve\n</code></pre>\n<p>...将它加入到你的配置文件中:</p>\n<pre><code><span class=\"hljs-comment\">// rollup.config.js</span>\n<span class=\"hljs-keyword\">import</span> resolve <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rollup-plugin-node-resolve'</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  <span class=\"hljs-attr\">input</span>: <span class=\"hljs-string\">'src/main.js'</span>,\n  <span class=\"hljs-attr\">output</span>: {\n    <span class=\"hljs-attr\">file</span>: <span class=\"hljs-string\">'bundle.js'</span>,\n    <span class=\"hljs-attr\">format</span>: <span class=\"hljs-string\">'cjs'</span>\n  },\n  <span class=\"hljs-attr\">plugins</span>: [ resolve() ]\n};\n</code></pre>\n<p>这次，当你运行 <code>npm run build</code>, 再没有警告输出 - 打包文件 bundle 包含了引用的模块。</p>\n<h4 id=\"rollup-plugin-commonjs\">rollup-plugin-commonjs</h4>\n<p>一些库导出成你可以正常导入的ES6模块 -<code>the-answer</code> 就是一个这样的模块。 但是目前，npm中的大多数包都是以CommonJS模块的形式出现的。 在它们更改之前，我们需要将CommonJS模块转换为 ES2015 供 Rollup 处理。</p>\n<p>这个 <a href=\"https://github.com/rollup/rollup-plugin-commonjs\">rollup-plugin-commonjs</a> 插件就是用来将 CommonJS 转换成 ES2015 模块的。</p>\n<p>请注意，<code>rollup-plugin-commonjs</code>应该用在其他插件转换你的模块<em>之前</em> - 这是为了防止其他插件的改变破坏CommonJS的检测。</p>\n<h3 id=\"peer-dependencies\">Peer dependencies</h3>\n<p>假设你正在构建一个具有对等依赖关系（peer dependency）的库，例如React或Lodash。 如果你如上所述设置外部引用（externals），你的 Rollup 将把 所有 imports 的模块打包在一起：</p>\n<pre><code><span class=\"hljs-keyword\">import</span> answer <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'the-answer'</span>;\n<span class=\"hljs-keyword\">import</span> _ <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'lodash'</span>;\n</code></pre>\n<p>你可以微调哪些导入是想要打包的，哪些是外部的引用（externals）。 对于这个例子，我们认为<code>lodash</code>是外部的引用（externals），而不是<code>the-answer</code>。</p>\n<p>这是配置文件:</p>\n<pre><code><span class=\"hljs-comment\">// rollup.config.js</span>\n<span class=\"hljs-keyword\">import</span> resolve <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rollup-plugin-node-resolve'</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  <span class=\"hljs-attr\">input</span>: <span class=\"hljs-string\">'src/main.js'</span>,\n  <span class=\"hljs-attr\">output</span>: {\n    <span class=\"hljs-attr\">file</span>: <span class=\"hljs-string\">'bundle.js'</span>,\n    <span class=\"hljs-attr\">format</span>: <span class=\"hljs-string\">'cjs'</span>\n  },\n  <span class=\"hljs-attr\">plugins</span>: [resolve({\n    <span class=\"hljs-comment\">// 将自定义选项传递给解析插件</span>\n    customResolveOptions: {\n      <span class=\"hljs-attr\">moduleDirectory</span>: <span class=\"hljs-string\">'node_modules'</span>\n    }\n  })],\n  <span class=\"hljs-comment\">// 指出应将哪些模块视为外部模块</span>\n  external: [<span class=\"hljs-string\">'lodash'</span>]\n};\n</code></pre>\n<p>这样，“lodash”现在将被视为外部的（externals），不会与你的库打包在一起。</p>\n<p><code>external</code> 接受一个模块名称的数组或一个接受模块名称的函数，如果它被视为外部引用（externals）则返回true。 例如：</p>\n<pre><code><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  <span class=\"hljs-comment\">// ...</span>\n  external: <span class=\"hljs-function\"><span class=\"hljs-params\">id</span> =&gt;</span> /lodash/.test(id)\n}\n</code></pre>\n<p>如果你使用 [babel-plugin-lodash]（<a href=\"https://github.com/lodash/babel-plugin-lodash）来最优选择lodash模块，在这种情况下，Babel将转换你的导入语句，如下所示\">https://github.com/lodash/babel-plugin-lodash）来最优选择lodash模块，在这种情况下，Babel将转换你的导入语句，如下所示</a></p>\n<pre><code><span class=\"hljs-keyword\">import</span> _merge <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'lodash/merge'</span>;\n</code></pre>\n<p>“external”的数组形式不会处理通配符，所以这个导入只会以函数的形式被视作外部依赖/引用（externals）。</p>\n<h3 id=\"babel\">Babel</h3>\n<p>许多开发人员在他们的项目中使用[Babel]（<a href=\"https://babeljs.io/），以便他们可以使用未被浏览器和Node.js支持的将来版本的\">https://babeljs.io/），以便他们可以使用未被浏览器和Node.js支持的将来版本的</a> JavaScript 特性。</p>\n<p>使用 Babel 和 Rollup 的最简单方法是使用 [rollup-plugin-babel]（<a href=\"https://github.com/rollup/rollup-plugin-babel）。\">https://github.com/rollup/rollup-plugin-babel）。</a> 安装它：</p>\n<pre><code>npm i -D rollup-plugin-babel\n</code></pre>\n<p>添加到Rollup配置文件 <code>rollup.config.js</code>:</p>\n<pre><code><span class=\"hljs-comment\">// rollup.config.js</span>\n<span class=\"hljs-keyword\">import</span> resolve <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rollup-plugin-node-resolve'</span>;\n<span class=\"hljs-keyword\">import</span> babel <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rollup-plugin-babel'</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  <span class=\"hljs-attr\">input</span>: <span class=\"hljs-string\">'src/main.js'</span>,\n  <span class=\"hljs-attr\">output</span>: {\n    <span class=\"hljs-attr\">file</span>: <span class=\"hljs-string\">'bundle.js'</span>,\n    <span class=\"hljs-attr\">format</span>: <span class=\"hljs-string\">'cjs'</span>\n  },\n  <span class=\"hljs-attr\">plugins</span>: [\n    resolve(),\n    babel({\n      <span class=\"hljs-attr\">exclude</span>: <span class=\"hljs-string\">'node_modules/**'</span> <span class=\"hljs-comment\">// 只编译我们的源代码</span>\n    })\n  ]\n};\n</code></pre>\n<p>在Babel实际编译代码之前，需要进行配置。 创建一个新文件<code>src/.babelrc</code>：</p>\n<pre><code>{\n  <span class=\"hljs-string\">\"presets\"</span>: [\n    [<span class=\"hljs-string\">\"latest\"</span>, {\n      <span class=\"hljs-string\">\"es2015\"</span>: {\n        <span class=\"hljs-string\">\"modules\"</span>: <span class=\"hljs-literal\">false</span>\n      }\n    }]\n  ],\n  <span class=\"hljs-string\">\"plugins\"</span>: [<span class=\"hljs-string\">\"external-helpers\"</span>]\n}\n</code></pre>\n<p>这个设置有一些不寻常的地方。首先，我们设置<code>&quot;modules&quot;: false</code>，否则 Babel 会在 Rollup 有机会做处理之前，将我们的模块转成 CommonJS，导致 Rollup 的一些处理失败。</p>\n<p>其次，我们使用<code>external-helpers</code>插件，它允许 Rollup 在包的顶部只引用一次 “helpers”，而不是每个使用它们的模块中都引用一遍（这是默认行为）。</p>\n<p>第三，我们将<code>.babelrc</code>文件放在<code>src</code>中，而不是根目录下。 这允许我们对于不同的任务有不同的<code>.babelrc</code>配置，比如像测试，如果我们以后需要的话 - 通常为单独的任务单独配置会更好。</p>\n<p>现在，在我们运行 rollup 之前，我们需要安装<code>latest</code> preset 和<code>external-helpers</code>插件</p>\n<pre><code>npm i -D babel-preset-latest babel-plugin-external-helpers\n</code></pre>\n<p>运行 Rollup 现在将创建一个 bundle 包... 实际上我们并没有使用任何ES2015特性。 我们来改变一下。 编辑<code>src / main.js</code>：</p>\n<pre><code><span class=\"hljs-comment\">// src/main.js</span>\n<span class=\"hljs-keyword\">import</span> answer <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'the-answer'</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> () =&gt; {\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`the answer is <span class=\"hljs-subst\">${answer}</span>`</span>);\n}\n</code></pre>\n<p>运行 Rollup <code>npm run build</code>，检查打包后的bundle：</p>\n<pre><code><span class=\"hljs-meta\">'use strict'</span>;\n\n<span class=\"hljs-keyword\">var</span> index = <span class=\"hljs-number\">42</span>;\n\n<span class=\"hljs-keyword\">var</span> main = (<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'the answer is '</span> + index);\n});\n\n<span class=\"hljs-built_in\">module</span>.exports = main;\n</code></pre>\n<h3 id=\"gulp\">Gulp</h3>\n<p>Rollup 返回 gulp 能明白的 promises，所以集成是很容易的。</p>\n<p>语法与配置文件非常相似，但属性分为两个不同的操作，对应于<a href=\"#JavaScript-API\">JavaScript API</a>：</p>\n<pre><code><span class=\"hljs-keyword\">const</span> gulp = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'gulp'</span>);\n<span class=\"hljs-keyword\">const</span> rollup = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'rollup'</span>);\n<span class=\"hljs-keyword\">const</span> rollupTypescript = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'rollup-plugin-typescript'</span>);\n\ngulp.task(<span class=\"hljs-string\">'build'</span>, <span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">const</span> bundle = <span class=\"hljs-keyword\">await</span> rollup.rollup({\n    <span class=\"hljs-attr\">input</span>: <span class=\"hljs-string\">'./src/main.ts'</span>,\n    <span class=\"hljs-attr\">plugins</span>: [\n      rollupTypescript()\n    ]\n  });\n\n  <span class=\"hljs-keyword\">await</span> bundle.write({\n    <span class=\"hljs-attr\">file</span>: <span class=\"hljs-string\">'./dist/library.js'</span>,\n    <span class=\"hljs-attr\">format</span>: <span class=\"hljs-string\">'umd'</span>,\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'library'</span>,\n    <span class=\"hljs-attr\">sourcemap</span>: <span class=\"hljs-literal\">true</span>\n  });\n});\n</code></pre>\n","metadata":{"title":"Rollup 与其他工具集成"},"subsections":[{"slug":"npm-packages","title":"npm packages"},{"slug":"peer-dependencies","title":"Peer dependencies"},{"slug":"babel","title":"Babel"},{"slug":"gulp","title":"Gulp"}],"slug":"tools"},{"html":"<p>以下内容旨在对<a href=\"https://www.ecma-international.org/ecma-262/6.0/\">ES2015规范</a>中定义的模块行为做一个轻量级的参考，因为对导入和导出语句的正确理解对于成功使用Rollup是至关重要的。</p>\n<h3 id=\"-importing-\">导入(Importing)</h3>\n<p>导入的值不能重新分配，尽管导入的对象和数组可以被修改（导出模块，以及任何其他的导入，都将受到该修改的影响）。在这种情况下，它们的行为与const声明类似。</p>\n<h4 id=\"-named-imports-\">命名导入(Named Imports)</h4>\n<p>从源模块导入其原始名称的特定项目。</p>\n<pre><code><span class=\"hljs-keyword\">import</span> { something } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./module.js'</span>;\n</code></pre>\n<p>从源模块导入特定项，并在导入时指定自定义名称。</p>\n<pre><code><span class=\"hljs-keyword\">import</span> { something <span class=\"hljs-keyword\">as</span> somethingElse } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./module.js'</span>;\n</code></pre>\n<h4 id=\"-namespace-imports-\">命名空间导入(Namespace Imports)</h4>\n<p>将源模块中的所有内容作为对象导入，将所有源模块的命名导出公开为属性和方法。默认导出被排除在此对象之外。</p>\n<pre><code><span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">module</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./module.js'</span>\n</code></pre>\n<p>上面的“something”的例子将被附加到作为属性的导入对象上。“module.something”。</p>\n<h4 id=\"-default-import-\">默认导入(Default Import)</h4>\n<p>导入源文件的<strong>默认导出</strong></p>\n<pre><code><span class=\"hljs-keyword\">import</span> something <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./module.js'</span>;\n</code></pre>\n<h4 id=\"-empty-import-\">空的导入(Empty Import)</h4>\n<p>加载模块代码，但不要创建任何新对象。</p>\n<pre><code><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'./module.js'</span>;\n</code></pre>\n<p>这对于polyfills是有用的，或者当导入的代码的主要目的是与原型有关的时候。</p>\n<h3 id=\"-exporting-\">导出(Exporting)</h3>\n<h4 id=\"-named-exports-\">命名导出(Named exports)</h4>\n<p>导出以前声明的值：</p>\n<pre><code><span class=\"hljs-keyword\">var</span> something = <span class=\"hljs-literal\">true</span>;\n<span class=\"hljs-keyword\">export</span> { something };\n</code></pre>\n<p>在导出时重命名：</p>\n<pre><code><span class=\"hljs-keyword\">export</span> { something <span class=\"hljs-keyword\">as</span> somethingElse };\n</code></pre>\n<p>声明后立即导出：</p>\n<pre><code><span class=\"hljs-comment\">// 这可以与 `var`, `let`, `const`, `class`, and `function` 配合使用</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">var</span> something = <span class=\"hljs-literal\">true</span>;\n</code></pre>\n<h4 id=\"-default-export-\">默认导出(Default Export)</h4>\n<p>导出一个值作为源模块的默认导出：</p>\n<pre><code><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> something;\n</code></pre>\n<p>仅当源模块只有一个导出时，才建议使用此做法。</p>\n<p>将默认和命名导出组合在同一模块中是不好的做法，尽管它是规范允许的。</p>\n<h3 id=\"-how-bindings-work-\">绑定是如何工作的(How bindings work)</h3>\n<p>ES模块导出<em>实时绑定</em>，而不是值，所以值可以在最初根据<a href=\"https://rollupjs.org/repl?shareable=JTdCJTIybW9kdWxlcyUyMiUzQSU1QiU3QiUyMm5hbWUlMjIlM0ElMjJtYWluLmpzJTIyJTJDJTIyY29kZSUyMiUzQSUyMmltcG9ydCUyMCU3QiUyMGNvdW50JTJDJTIwaW5jcmVtZW50JTIwJTdEJTIwZnJvbSUyMCcuJTJGaW5jcmVtZW50ZXIuanMnJTNCJTVDbiU1Q25jb25zb2xlLmxvZyhjb3VudCklM0IlNUNuaW5jcmVtZW50KCklM0IlNUNuY29uc29sZS5sb2coY291bnQpJTNCJTIyJTdEJTJDJTdCJTIybmFtZSUyMiUzQSUyMmluY3JlbWVudGVyLmpzJTIyJTJDJTIyY29kZSUyMiUzQSUyMmV4cG9ydCUyMGxldCUyMGNvdW50JTIwJTNEJTIwMCUzQiU1Q24lNUNuZXhwb3J0JTIwZnVuY3Rpb24lMjBpbmNyZW1lbnQoKSUyMCU3QiU1Q24lNUN0Y291bnQlMjAlMkIlM0QlMjAxJTNCJTVDbiU3RCUyMiU3RCU1RCUyQyUyMm9wdGlvbnMlMjIlM0ElN0IlMjJmb3JtYXQlMjIlM0ElMjJjanMlMjIlMkMlMjJnbG9iYWxzJTIyJTNBJTdCJTdEJTJDJTIybW9kdWxlSWQlMjIlM0ElMjIlMjIlMkMlMjJuYW1lJTIyJTNBJTIybXlCdW5kbGUlMjIlN0QlMkMlMjJleGFtcGxlJTIyJTNBbnVsbCU3RA==\">这个示例</a>导入后更改：</p>\n<pre><code><span class=\"hljs-comment\">// incrementer.js</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">let</span> count = <span class=\"hljs-number\">0</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">increment</span>(<span class=\"hljs-params\"></span>) </span>{\n  count += <span class=\"hljs-number\">1</span>;\n}\n</code></pre>\n<pre><code><span class=\"hljs-comment\">// main.js</span>\n<span class=\"hljs-keyword\">import</span> { count, increment } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./incrementer.js'</span>;\n\n<span class=\"hljs-built_in\">console</span>.log(count); <span class=\"hljs-comment\">// 0</span>\nincrement();\n<span class=\"hljs-built_in\">console</span>.log(count); <span class=\"hljs-comment\">// 1</span>\n\ncount += <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// Error — 只有 incrementer.js 可以改变这个值。</span>\n</code></pre>\n","metadata":{"title":"ES模块语法"},"subsections":[{"slug":"-importing-","title":"导入"},{"slug":"-exporting-","title":"导出"},{"slug":"-how-bindings-work-","title":"绑定是如何工作的"}],"slug":"es-module-syntax"},{"html":"<h3 id=\"-core-functionality-\">核心功能(Core functionality)</h3>\n<h4 id=\"-input-i-input-\">输入(input <em><code>-i</code>/<code>--input</code></em>)</h4>\n<p><code>String</code> 这个包的入口点 (例如：你的 <code>main.js</code> 或者 <code>app.js</code> 或者 <code>index.js</code>)</p>\n<h4 id=\"-file-o-output-file-\">文件(file <em><code>-o</code>/<code>--output.file</code></em>)</h4>\n<p><code>String</code> 要写入的文件。也可用于生成 sourcemaps，如果适用</p>\n<h4 id=\"-format-f-output-format-\">格式(format <em><code>-f</code>/<code>--output.format</code></em>)</h4>\n<p><code>String</code> 生成包的格式。 下列之一:</p>\n<ul>\n<li><code>amd</code> – 异步模块定义，用于像RequireJS这样的模块加载器</li>\n<li><code>cjs</code> – CommonJS，适用于 Node 和 Browserify/Webpack</li>\n<li><code>es</code> – 将软件包保存为ES模块文件</li>\n<li><code>iife</code> – 一个自动执行的功能，适合作为<code>&lt;script&gt;</code>标签。（如果要为应用程序创建一个捆绑包，您可能想要使用它，因为它会使文件大小变小。）</li>\n<li><code>umd</code> – 通用模块定义，以<code>amd</code>，<code>cjs</code> 和 <code>iife</code> 为一体</li>\n</ul>\n<h4 id=\"-name-n-name-\">生成包名称(name <em><code>-n</code>/<code>--name</code></em>)</h4>\n<p><code>String</code> 变量名，代表你的 <code>iife</code>/<code>umd</code> 包，同一页上的其他脚本可以访问它。</p>\n<pre><code><span class=\"hljs-comment\">// rollup.config.js</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  ...,\n  <span class=\"hljs-attr\">output</span>: {\n    <span class=\"hljs-attr\">file</span>: <span class=\"hljs-string\">'bundle.js'</span>,\n    <span class=\"hljs-attr\">format</span>: <span class=\"hljs-string\">'iife'</span>,\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'MyBundle'</span>\n  }\n};\n\n<span class=\"hljs-comment\">// -&gt; var MyBundle = (function () {...</span>\n</code></pre>\n<h4 id=\"-plugins-\">插件(plugins)</h4>\n<p>插件对象 <code>数组 Array</code> (或一个插件对象) – 有关详细信息请参阅 <a href=\"#getting-started-with-plugins\">插件入门</a>。记住要调用导入的插件函数(即 <code>commonjs()</code>, 而不是 <code>commonjs</code>).</p>\n<pre><code><span class=\"hljs-comment\">// rollup.config.js</span>\n<span class=\"hljs-keyword\">import</span> resolve <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rollup-plugin-node-resolve'</span>;\n<span class=\"hljs-keyword\">import</span> commonjs <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rollup-plugin-commonjs'</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  <span class=\"hljs-attr\">entry</span>: <span class=\"hljs-string\">'main.js'</span>,\n  <span class=\"hljs-attr\">plugins</span>: [\n    resolve(),\n    commonjs()\n  ]\n};\n</code></pre>\n<h4 id=\"-external-e-external-\">外链(external <em><code>-e</code>/<code>--external</code></em>)</h4>\n<p>两者任一 <code>Function</code> 需要一个 <code>id</code> 并返回 <code>true</code>（外部引用）或 <code>false</code>（不是外部的引用），\n或者 <code>Array</code> 应该保留在bundle的外部引用的模块ID。ID应该是：</p>\n<ol>\n<li>外部依赖的名称</li>\n<li>一个已被找到路径的ID（像文件的绝对路径）</li>\n</ol>\n<pre><code><span class=\"hljs-comment\">// rollup.config.js</span>\n<span class=\"hljs-keyword\">import</span> path <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'path'</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  ...,\n  <span class=\"hljs-attr\">external</span>: [\n    <span class=\"hljs-string\">'some-externally-required-library'</span>,\n    path.resolve( <span class=\"hljs-string\">'./src/some-local-file-that-should-not-be-bundled.js'</span> )\n  ]\n};\n</code></pre>\n<p>当作为命令行参数给出时，它应该是以逗号分隔的ID列表：</p>\n<pre><code>rollup -i src/main.js ... -e foo,bar,baz\n</code></pre>\n<h4 id=\"-globals-g-globals-\">全局模块(globals <em><code>-g</code>/<code>--globals</code></em>)</h4>\n<p><code>Object</code> 形式的 <code>id: name</code> 键值对，用于<code>umd</code>/<code>iife</code>包。例如：在这样的情况下...</p>\n<pre><code><span class=\"hljs-keyword\">import</span> $ <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'jquery'</span>;\n</code></pre>\n<p>...我们想告诉 Rollup <code>jquery</code> 模块的id等同于 <code>$</code> 变量:</p>\n<pre><code><span class=\"hljs-comment\">// rollup.config.js</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  ...,\n  <span class=\"hljs-attr\">format</span>: <span class=\"hljs-string\">'iife'</span>,\n  <span class=\"hljs-attr\">moduleName</span>: <span class=\"hljs-string\">'MyBundle'</span>,\n  <span class=\"hljs-attr\">globals</span>: {\n    <span class=\"hljs-attr\">jquery</span>: <span class=\"hljs-string\">'$'</span>\n  }\n};\n\n<span class=\"hljs-comment\">/*\nvar MyBundle = (function ($) {\n  // 代码到这里\n}(window.jQuery));\n*/</span>.\n</code></pre>\n<p>或者，提供将外部模块ID转换为全局模块的功能。</p>\n<p>当作为命令行参数给出时，它应该是一个逗号分隔的“id：name”键值对列表：</p>\n<pre><code>rollup -i src/main.js ... -g jquery:$,underscore:_\n</code></pre>\n<h3 id=\"-advanced-functionality-\">高功功能(Advanced functionality)</h3>\n<h4 id=\"-paths-\">路径(paths)</h4>\n<p><code>Function</code>，它获取一个ID并返回一个路径，或者<code>id：path</code>对的<code>Object</code>。在提供的位置，这些路径将被用于生成的包而不是模块ID，从而允许您（例如）从CDN加载依赖关系：</p>\n<pre><code><span class=\"hljs-comment\">// app.js</span>\n<span class=\"hljs-keyword\">import</span> { selectAll } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'d3'</span>;\nselectAll(<span class=\"hljs-string\">'p'</span>).style(<span class=\"hljs-string\">'color'</span>, <span class=\"hljs-string\">'purple'</span>);\n<span class=\"hljs-comment\">// ...</span>\n\n<span class=\"hljs-comment\">// rollup.config.js</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  <span class=\"hljs-attr\">input</span>: <span class=\"hljs-string\">'app.js'</span>,\n  <span class=\"hljs-attr\">external</span>: [<span class=\"hljs-string\">'d3'</span>],\n  <span class=\"hljs-attr\">output</span>: {\n    <span class=\"hljs-attr\">file</span>: <span class=\"hljs-string\">'bundle.js'</span>,\n    <span class=\"hljs-attr\">format</span>: <span class=\"hljs-string\">'amd'</span>,\n    <span class=\"hljs-attr\">paths</span>: {\n      <span class=\"hljs-attr\">d3</span>: <span class=\"hljs-string\">'https://d3js.org/d3.v4.min'</span>\n    }\n  }\n};\n\n<span class=\"hljs-comment\">// bundle.js</span>\ndefine([<span class=\"hljs-string\">'https://d3js.org/d3.v4.min'</span>], <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">d3</span>) </span>{\n\n  d3.selectAll(<span class=\"hljs-string\">'p'</span>).style(<span class=\"hljs-string\">'color'</span>, <span class=\"hljs-string\">'purple'</span>);\n  <span class=\"hljs-comment\">// ...</span>\n\n});\n</code></pre>\n<h4 id=\"banner-footer\">banner/footer</h4>\n<p><code>String</code> 字符串以 前置/追加 到文件束(bundle)。(注意:“banner”和“footer”选项不会破坏sourcemaps)</p>\n<pre><code><span class=\"hljs-comment\">// rollup.config.js</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  ...,\n  <span class=\"hljs-attr\">banner</span>: <span class=\"hljs-string\">'/* my-library version '</span> + version + <span class=\"hljs-string\">' */'</span>,\n  <span class=\"hljs-attr\">footer</span>: <span class=\"hljs-string\">'/* follow me on Twitter! @rich_harris */'</span>\n};\n</code></pre>\n<h4 id=\"intro-outro\">intro/outro</h4>\n<p><code>String</code>类似于 <code>banner</code>和<code>footer</code>，除了代码在<em>内部</em>任何特定格式的包装器(wrapper)</p>\n<pre><code><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  ...,\n  <span class=\"hljs-attr\">intro</span>: <span class=\"hljs-string\">'var ENVIRONMENT = \"production\";'</span>\n};\n</code></pre>\n<h4 id=\"-cache-\">缓存(cache)</h4>\n<p><code>Object</code> 以前生成的包。使用它来加速后续的构建——Rollup只会重新分析已经更改的模块。</p>\n<h4 id=\"onwarn\">onwarn</h4>\n<p><code>Function</code> 将拦截警告信息。如果没有提供，警告将被复制并打印到控制台。</p>\n<p>警告是至少有一个<code>code</code> 和 <code>message</code>属性的对象，这意味着您可以控制如何处理不同类型的警告：</p>\n<pre><code>onwarn (warning) {\n  <span class=\"hljs-comment\">// 跳过某些警告</span>\n  <span class=\"hljs-keyword\">if</span> (warning.code === <span class=\"hljs-string\">'UNUSED_EXTERNAL_IMPORT'</span>) <span class=\"hljs-keyword\">return</span>;\n\n  <span class=\"hljs-comment\">// 抛出异常</span>\n  <span class=\"hljs-keyword\">if</span> (warning.code === <span class=\"hljs-string\">'NON_EXISTENT_EXPORT'</span>) <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(warning.message);\n\n  <span class=\"hljs-comment\">// 控制台打印一切警告</span>\n  <span class=\"hljs-built_in\">console</span>.warn(warning.message);\n}\n</code></pre>\n<p>许多警告也有一个<code>loc</code>属性和一个<code>frame</code>，你可以定位到警告的来源：</p>\n<pre><code>onwarn ({ loc, frame, message }) {\n  <span class=\"hljs-comment\">// 打印位置（如果适用）</span>\n  <span class=\"hljs-keyword\">if</span> (loc) {\n    <span class=\"hljs-built_in\">console</span>.warn(<span class=\"hljs-string\">`<span class=\"hljs-subst\">${loc.file}</span> (<span class=\"hljs-subst\">${loc.line}</span>:<span class=\"hljs-subst\">${loc.column}</span>) <span class=\"hljs-subst\">${message}</span>`</span>);\n    <span class=\"hljs-keyword\">if</span> (frame) <span class=\"hljs-built_in\">console</span>.warn(frame);\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-built_in\">console</span>.warn(message);\n  }\n}\n</code></pre>\n<h4 id=\"sourcemap-m-sourcemap-\">sourcemap <em><code>-m</code>/<code>--sourcemap</code></em></h4>\n<p>如果 <code>true</code>，将创建一个单独的sourcemap文件。如果 <code>inline</code>，sourcemap将作为数据URI附加到生成的<code>output</code>文件中。</p>\n<h4 id=\"sourcemapfile\">sourcemapFile</h4>\n<p><code>String</code>生成的包的位置。如果这是一个绝对路径，sourcemap中的所有源代码路径都将相对于它。 <code>map.file</code>属性是<code>sourcemapFile</code>的基本名称(basename)，因为sourcemap的位置被假定为与bundle相邻</p>\n<p>如果指定 <code>output</code>，<code>sourcemapFile</code> 不是必需的，在这种情况下，将通过给bundle输出文件添加 “.map” 后缀来推断输出文件名。</p>\n<h4 id=\"interop\">interop</h4>\n<p><code>Boolean</code> 是否添加&#39;interop块&#39;。默认情况下（<code>interop：true</code>），为了安全起见，如果需要区分默认和命名导出，则Rollup会将任何外部依赖项“default”导出到一个单独的变量。这通常只适用于您的外部依赖关系（例如与Babel）（如果您确定不需要它），则可以使用“interop：false”来节省几个字节。</p>\n<h3 id=\"-danger-zone-\">危险区域(Danger zone)</h3>\n<p>你可能不需要使用这些选项，除非你知道你在做什么!</p>\n<h4 id=\"treeshake\">treeshake</h4>\n<p>是否应用tree-shaking。建议您省略此选项（默认为<code>treeshake：true</code>），除非您发现由tree-shaking算法引起的bug，在这种情况下，请使用“treeshake：false”，一旦您提交了问题！</p>\n<h4 id=\"acorn\">acorn</h4>\n<p>任何应该传递给Acorn的选项，例如<code>allowReserved：true</code>。</p>\n<h4 id=\"context\">context</h4>\n<p>默认情况下，模块的上下文 - 即顶级的<code>this</code>的值为<code>undefined</code>。在极少数情况下，您可能需要将其更改为其他内容，如 <code>&#39;window&#39;</code>。</p>\n<h4 id=\"modulecontext\">moduleContext</h4>\n<p>和<code>options.context</code>一样，但是每个模块可以是<code>id: context</code>对的对象，也可以是<code>id =&gt; context</code>函数。</p>\n<h4 id=\"legacy\">legacy</h4>\n<p>为了增加对诸如IE8之类的旧版环境的支持，通过剥离更多可能无法正常工作的现代化的代码，其代价是偏离ES6模块环境所需的精确规范。</p>\n<h4 id=\"exports\">exports</h4>\n<p><code>String</code> 使用什么导出模式。默认为<code>auto</code>，它根据<code>entry</code>模块导出的内容猜测你的意图：</p>\n<ul>\n<li><code>default</code> – 如果你使用 <code>export default ...</code> 仅仅导出一个东西，那适合用这个</li>\n<li><code>named</code> – 如果你导出多个东西，适合用这个</li>\n<li><code>none</code> – 如果你不导出任何内容 (例如，你正在构建应用程序，而不是库)，则适合用这个</li>\n</ul>\n<p><code>default</code> 和 <code>named</code>之间的区别会影响其他人如何使用文件束(bundle)。如果您使用<code>default</code>，则CommonJS用户可以执行此操作，例如</p>\n<pre><code><span class=\"hljs-keyword\">var</span> yourLib = <span class=\"hljs-built_in\">require</span>( <span class=\"hljs-string\">'your-lib'</span> );\n</code></pre>\n<p>使用 <code>named</code>，用户可以这样做：</p>\n<pre><code><span class=\"hljs-keyword\">var</span> yourMethod = <span class=\"hljs-built_in\">require</span>( <span class=\"hljs-string\">'your-lib'</span> ).yourMethod;\n</code></pre>\n<p>有点波折就是如果你使用<code>named</code>导出，但是<em>同时也</em>有一个<code>default</code>导出，用户必须这样做才能使用默认的导出：</p>\n<pre><code><span class=\"hljs-keyword\">var</span> yourMethod = <span class=\"hljs-built_in\">require</span>( <span class=\"hljs-string\">'your-lib'</span> ).yourMethod;\n<span class=\"hljs-keyword\">var</span> yourLib = <span class=\"hljs-built_in\">require</span>( <span class=\"hljs-string\">'your-lib'</span> )[<span class=\"hljs-string\">'default'</span>];\n</code></pre>\n<h4 id=\"amd-amd-id-and-amd-define-\">amd <em><code>--amd.id</code> and <code>--amd.define</code></em></h4>\n<p><code>Object</code> 可以包含以下属性：</p>\n<p><strong>amd.id</strong> <code>String</code> 用于 AMD/UMD 软件包的ID：</p>\n<pre><code><span class=\"hljs-comment\">// rollup.config.js</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  ...,\n  <span class=\"hljs-attr\">format</span>: <span class=\"hljs-string\">'amd'</span>,\n  <span class=\"hljs-attr\">amd</span>: {\n    <span class=\"hljs-attr\">id</span>: <span class=\"hljs-string\">'my-bundle'</span>\n  }\n};\n\n<span class=\"hljs-comment\">// -&gt; define('my-bundle', ['dependency'], ...</span>\n</code></pre>\n<p><strong>amd.define</strong> <code>String</code> 要使用的函数名称，而不是 <code>define</code>:</p>\n<pre><code><span class=\"hljs-comment\">// rollup.config.js</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  ...,\n  <span class=\"hljs-attr\">format</span>: <span class=\"hljs-string\">'amd'</span>,\n  <span class=\"hljs-attr\">amd</span>: {\n    <span class=\"hljs-attr\">define</span>: <span class=\"hljs-string\">'def'</span>\n  }\n};\n\n<span class=\"hljs-comment\">// -&gt; def(['dependency'],...</span>\n</code></pre>\n<h4 id=\"indent\">indent</h4>\n<p><code>String</code> 是要使用的缩进字符串，对于需要缩进代码的格式（<code>amd</code>，<code>iife</code>，<code>umd</code>）。也可以是<code>false</code>（无缩进）或<code>true</code>（默认 - 自动缩进）</p>\n<pre><code><span class=\"hljs-comment\">// rollup.config.js</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  ...,\n  <span class=\"hljs-attr\">indent</span>: <span class=\"hljs-literal\">false</span>\n};\n</code></pre>\n<h4 id=\"strict\">strict</h4>\n<p><code>true</code>或<code>false</code>（默认为<code>true</code>） - 是否在生成的非ES6软件包的顶部包含&#39;use strict&#39;pragma。严格来说（geddit？），ES6模块<em>始终都是</em>严格模式，所以你应该没有很好的理由来禁用它。</p>\n<h3 id=\"watch-options\">Watch options</h3>\n<p>这些选项仅在运行 Rollup 时使用 <code>--watch</code> 标志或使用 <code>rollup.watch</code> 时生效。</p>\n<h4 id=\"watch-chokidar\">watch.chokidar</h4>\n<p>一个 <code>Boolean</code> 值表示应该使用 <a href=\"https://github.com/paulmillr/chokidar\">chokidar</a> 而不是内置的 <code>fs.watch</code>，或者是一个传递给 chokidar 的选项对象。</p>\n<p>如果你希望使用它，你必须单独安装chokidar。</p>\n<h4 id=\"watch-include\">watch.include</h4>\n<p>限制文件监控至某些文件：</p>\n<pre><code><span class=\"hljs-comment\">// rollup.config.js</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  ...,\n  <span class=\"hljs-attr\">watch</span>: {\n    <span class=\"hljs-attr\">include</span>: <span class=\"hljs-string\">'src/**'</span>\n  }\n};\n</code></pre>\n<h4 id=\"watch-exclude\">watch.exclude</h4>\n<p>防止文件被监控：</p>\n<pre><code><span class=\"hljs-comment\">// rollup.config.js</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  ...,\n  <span class=\"hljs-attr\">watch</span>: {\n    <span class=\"hljs-attr\">exclude</span>: <span class=\"hljs-string\">'node_modules/**'</span>\n  }\n};\n</code></pre>\n","metadata":{"title":"大选项列表"},"subsections":[{"slug":"-core-functionality-","title":"核心功能"},{"slug":"-advanced-functionality-","title":"高功功能"},{"slug":"-danger-zone-","title":"危险区域"},{"slug":"watch-options","title":"Watch options"}],"slug":"big-list-of-options"},{"html":"<h3 id=\"-domain-sponsorship-\">域名赞助(domain sponsorship)</h3>\n<ul>\n<li><a href=\"https://github.com/pasturn\">pasturn</a></li>\n</ul>\n<h3 id=\"-translator-\">翻译人员(translator)</h3>\n<ul>\n<li><a href=\"https://github.com/lcxfs1991\">heyli</a></li>\n<li><a href=\"https://github.com/dear-lizhihua\">lizhihua</a></li>\n<li><a href=\"https://github.com/wangjianhui2464\">wangjianhui2464</a></li>\n<li><a href=\"https://github.com/huangtubiao\">huangtubiao</a></li>\n<li><a href=\"https://github.com/zhenizhui\">zhenizhui</a></li>\n<li><a href=\"https://github.com/Aladdin-ADD\">Aladdin-ADD</a></li>\n</ul>\n","metadata":{"title":"贡献者"},"subsections":[{"slug":"-domain-sponsorship-","title":"域名赞助"},{"slug":"-translator-","title":"翻译人员"}],"slug":"contributors"}]